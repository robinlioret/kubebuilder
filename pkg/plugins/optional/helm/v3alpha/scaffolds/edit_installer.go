/*
Copyright 2026 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scaffolds

import (
	"fmt"
	"io"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"

	"gopkg.in/yaml.v2"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"sigs.k8s.io/kubebuilder/v4/pkg/config"
	"sigs.k8s.io/kubebuilder/v4/pkg/machinery"
	"sigs.k8s.io/kubebuilder/v4/pkg/plugins"
	"sigs.k8s.io/kubebuilder/v4/pkg/plugins/optional/helm/v3alpha/scaffolds/internal/templates"
)

const (
	defaultManifestsFile = "dist/install.yaml"
)

var _ plugins.Scaffolder = &editInstallerScaffolder{}

type editInstallerScaffolder struct {
	config        config.Config
	fs            machinery.Filesystem
	force         bool
	manifestsFile string
	outputDir     string
}

// NewInstallerHelmScaffolder returns a new Scaffolder for HelmPlugin using kustomize output
func NewInstallerHelmScaffolder(cfg config.Config, force bool, manifestsFile, outputDir string) plugins.Scaffolder {
	return &editInstallerScaffolder{
		config:        cfg,
		force:         force,
		manifestsFile: manifestsFile,
		outputDir:     outputDir,
	}
}

// InjectFS implements cmdutil.Scaffolder
func (s *editInstallerScaffolder) InjectFS(fs machinery.Filesystem) {
	s.fs = fs
}

// Scaffold generates the complete Helm chart from kustomize output
func (s *editInstallerScaffolder) Scaffold() error {
	slog.Info("Generating Helm Chart from kustomize output")

	// Ensure chart directory structure exists
	if err := s.ensureChartDirectoryExists(); err != nil {
		return fmt.Errorf("failed to create chart directory: %w", err)
	}

	// Generate fresh kustomize output if using default file
	if s.manifestsFile == defaultManifestsFile {
		if err := s.generateInstallerOutput(); err != nil {
			return fmt.Errorf("failed to generate kustomize output: %w", err)
		}
	}

	// Parse the manifests to a usable resource set
	resources, err := s.parse()
	if err != nil {
		return fmt.Errorf("failed to parse installer: %w", err)
	}

	// to test
	fmt.Println("Resources", len(resources))

	// Create scaffold for standard Helm chart files
	scaffold := machinery.NewScaffold(s.fs, machinery.WithConfig(s.config))

	// Define the standard Helm chart files to generate
	chartFiles := []machinery.Builder{
		&templates.HelmGithubCITestChart{},             // GitHub Actions workflow for chart testing
		&templates.HelmChart{OutputDir: s.outputDir},   // Chart.yaml metadata
		&templates.HelmIgnore{OutputDir: s.outputDir},  // .helmignore file
		&templates.HelmHelpers{OutputDir: s.outputDir}, // _helpers.tpl template functions
	}

	// Generate standard Helm chart files
	if err = scaffold.Execute(chartFiles...); err != nil {
		return fmt.Errorf("failed to generate Helm chart files: %w", err)
	}

	slog.Info("Helm Chart generation completed successfully")
	return nil
}

// generateInstallerOutput runs make build-installer to generate the manifests file
func (s *editInstallerScaffolder) generateInstallerOutput() error {
	slog.Info("Generating kustomize output with make build-installer")

	// Check if Makefile exists
	if _, err := os.Stat("Makefile"); os.IsNotExist(err) {
		return fmt.Errorf("makefile not found in current directory")
	}

	// Run make build-installer
	cmd := exec.Command("make", "build-installer")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to run make build-installer: %w", err)
	}

	// Verify that the manifests file was created
	if _, err := os.Stat(defaultManifestsFile); os.IsNotExist(err) {
		return fmt.Errorf("%s was not generated by make build-installer", defaultManifestsFile)
	}

	return nil
}

// ensureChartDirectoryExists creates the chart directory structure if it doesn't exist
func (s *editInstallerScaffolder) ensureChartDirectoryExists() error {
	dirs := []string{
		filepath.Join(s.outputDir, "chart"),
		filepath.Join(s.outputDir, "chart", "templates"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

func (s *editInstallerScaffolder) parse() ([]*unstructured.Unstructured, error) {
	file, err := os.Open(s.manifestsFile)
	if err != nil {
		return nil, fmt.Errorf("failed to open manifests file: %w", err)
	}
	defer func() {
		_ = file.Close()
	}()

	var objs []*unstructured.Unstructured
	decoder := yaml.NewDecoder(file)

	for {
		var raw map[string]any
		err := decoder.Decode(&raw)
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("failed to parse manifests file: %w", err)
		}
		if len(raw) == 0 {
			continue // Skip empty documents
		}
		obj := &unstructured.Unstructured{Object: raw}
		objs = append(objs, obj)
	}

	return objs, nil
}
